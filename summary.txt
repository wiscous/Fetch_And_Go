1. Why did you choose the tools, libraries, and language you used for the coding exercise?

I mainly used Go because it offers a good balance of performance and ease of use. If one treats the assignment as a potential real world project then Go's robust asynchronous programming support, library ecosystem along with straightforward syntax with static typing gives significant benefits if the scope of the project expands in the future to include parallelism or incorporation of additional developers who should be able to quickly become productive on the job.

The code was written using Neovim with intellisense setup for autocompletion. I also used delve for debugging.

To summarize
Programming language: Go
Libraries: The Go standard library (and no other dependencies)
Tools: Delve for debugging, Neovim with LSP powered autocompletion setup

2. What are the advantages and disadvantages of your solution?
Advantages
- The code has decent error handling and error messages for a small script and should not result in  opaque errors.
- The performance of the code should be decent. The file is read as a stream using the Reader interface and the algorithm runs in the order of N.Log(N) where N is the number of transactions to be processed.
- The code has documentation in areas where it is necessary to give additional context.

Disadvantages
- Could handle more error cases and common invalid inputs. Currently we just skip lines which we parse as invalid records.
- Perhaps the code could include more documentation to explain the expected input format .



3. What has been a favorite school/personal project thus far? What about it that challenged you?
My favorite one is a personal project I worked on a year and half back. I implemented an interpreter for a Javascript-like language Lox (Classes, inheritance, closure functions, automatic memory management) using Python and Rust. I initially implemented it as a Treewalk interpreter in python. Using python allowed me to implement it faster and also lean on Python's own Garbage collector for memory management, but the performance was unsatisfactory compared to the reference Java implementation in the Crafting interpreters book, mainly due to Python not being optimized for performance compared to lanaguages like Go, C++ or Rust.

I reimplemented Lox as a Bytecode compiler and interpreter in Rust with a single threaded Mark-sweep garbage collector. The rust implementation was 100 times faster. Mainly due to a combination of Bytecode interpreters offering better cache behaviour along with Rust allowing fine control of memory allocation and usage since it is a systems language.

Challenges:
- While the bytecode interpreter was straight up faster than the previous treewalk interpreters, further improving performance required painstaking profiling to file bottlenecks in the implementation. This included areas such as unmarshalling the bytecode in the interpreter loop or the frequency or the conditions to trigger the garbage collector.

- The bytecode interpreter was implemented as a single pass compiler directly compiling the language down to bytecode in a single pass. While this decison made the implementation faster, it also made language features such as loops harder to implement since we need to patch prior generated bytecode to include the jump offsets. 

- Handling broken code and providing good diagnostics was also a challenge. Parsing the intention behind incorrect code and giving good and useful diagnostics is also a difficult task since we need to maintain additional context linked to the generated bytecode.

